# 第二次：OOP 面向对象

## 面向对象概念

我们在前面已经学习了面向过程编程，也可以自行编写出简单的程序了。我们接着就需要认识 面向对象程序设计（Object Oriented Programming）它是我们在Java语言中要学习的重要内容，面向对象也是高级语言的一大重要特性。

## 类与对象

### 类与对象概念

- **对象**：对象是类的一个实例（instance），有**属性**和**行为**。例如，一条狗是一个对象，它的属性有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。
- **类**：类是一个模板，它描述一类对象的行为和状态。

> 所以说，类就是抽象概念的狗，而对象，就是具体的某一条狗。

而我们在Java中，也可以像这样进行编程，我们可以定义一个类，然后进一步创建许多这个类的实例对象。像这种编程方式，我们称为面向对象编程。

### 类的与对象创建 

#### 类的创建

比如现在我们想要定义一个狗类，我们可以右键src目录，点击创建新的类：

![image 20221109155923526](https://s1.ax1x.com/2022/11/10/zpQtMV.png)

`我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。`

现在我们就创建好了一个类，既然是狗类，那么肯定有狗相关的一些**属性**，接下来我们为这个狗类添加一些相关的属性：

```java
public class Dog {
    //狗的名字
    String name;
    //狗的颜色
    String colour;
    //狗的年龄
    int age;
}
```

可以看见我们是直接将这些属性作为**类的成员变量**定义到类中。

> 一个类可以包含以下类型变量：

>- **局部变量**：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。
>- **成员变量**：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。
>- **类变量**：类变量也声明在类中，方法体之外，但必须声明为 static 类型，也被称为静态变量。

狗除了名字、品种等属性之外还具有吃、叫等行为，接下来我们为这个狗类增加一点行为：

```java
public class Dog {
    //狗的名字
    String name;
    //狗的颜色
    String colour;
    //狗的年龄
    int age;

    void eat() {
    }

    void run() {
    }

    void sleep(){
    }

}
```

可以看见我们是用方法来为这个类增加行为，在上面的例子中：eat()、run()、sleep() 和 name() 都是 Dog 类的方法。这样一个狗类就创建好了。

#### 方法创建与使用 

前面我们介绍了类和对象的定义以及类的创建。那么在我介绍对象的创建和使用之前我们先要了解一下方法的创建和使用。

之前我们说了在定义狗狗的行为的时候，在Dog类中增加了几个方法。

##### 方法的定义

```java
修饰符 返回值类型 方法名(参数类型 参数名){
    ...
    方法体
    ...
    return 返回值;
}
```

- **修饰符：**修饰符，`这是可选的`，告诉编译器如何调用该方法。定义了该方法的访问类型。
- **返回值类型 ：**方法可能会有返回值。returnValueType 是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字**void**。
- **方法名：**是方法的实际名称。方法名和参数表共同构成方法签名。
- **参数类型：**参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。
- **方法体：**方法体包含具体的语句，定义该方法的功能。

`TIPS:方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。`

###### 关于return关键字，我们还需要进行进一步的介绍。

在我们使用return关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F19%2FUCcAb9L8lfOzXMZ.png&sign=23195573de37d59c0d283ef1a7b0f2a5d326ebd1daad8ba370463068bce8734f)

在return后编写代码，会导致编译不通过，因为存在不可达语句。如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F19%2FWjUlRrPwA9EXThV.png&sign=ac6125b7bf07f5a59c19c5fc15af597d9221bd64c00e896c6641a68dc4220025)

只要有任何一个分支缺少了return语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。

当然，如果方法没有返回值，我们也可以使用return语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行。

##### 构造方法

此处我们介绍一个概念构造方法。每个类都有构造方法。如果没有显式地为类定义构造方法，Java 编译器将会为该类提供一个默认构造方法。在**创建一个对象**的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，一个类可以有多个构造方法。

```java
public Dog(){
    //无参构造
}

public Dog(String name,String colour,int age){
    //全参构造
    this.name = name;
    this.colour = colour;
    this.age = age;
}
```

###### this关键字

![F2A8BD9C70CD011ED4A3E9D3CFC136AD](https://s1.ax1x.com/2022/11/10/zpQdZF.jpg)

大部分时候，普通方法访问其他方法、成员变量时无须使用 this 前缀，但如果方法里有个局部变量和成员变量同名，但程序又需要在该方法里访问这个被覆盖的成员变量，则必须使用 this 前缀。

#### 对象的创建与使用

##### 对象的创建

对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：

- **声明**：声明一个对象，包括对象名称和对象类型。
- **实例化**：使用关键字 new 来创建一个对象。
- **初始化**：使用 new 创建对象时，会调用构造方法初始化对象。

那么介绍完构造方法后我们就可以正式开始创造自己的小狗狗🐕啦

```java
public class Main {
    public static void main(String[] args) {
        //调用无参构造
       Dog myDog = new Dog();
       //调用有参构造
       Dog myDoggy = new Dog("doggy","orange and white",1);
    }
}
```

只不过这里仅仅是创建出了这样的一个对象，我们目前没有办法去操作这个对象，比如想要修改或是获取这个人的名字等等。既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。

**此时我们可以在Dog类中增加get(),set()方法**

```java
public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public String getColour() {
    return colour;
}

public void setColour(String colour) {
    this.colour = colour;
}

public int getAge() {
    return age;
}

public void setAge(int age) {
    this.age = age;
}
```

这样我们就可以自由的获得和修改你创建的小狗狗的值了，就像这样：

```java
myDoggy.setAge(2);
System.out.println(myDoggy.getAge());
```

##  封装、继承和多态 

封装、继承和多态是面向对象编程的三大特性。

- 封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。

- 继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。

- 多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。

正是这三大特性，让我们的Java程序更加生动形象。

###  类的封装 

封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。

我们可以将之前的Dog类进行改进：

```java
public class Dog {
    //狗的名字
    private String name;
    //狗的颜色
    private String colour;
    //狗的年龄
    private int age;
```

我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象，通过这种方式，我们可以实现单例模式。不过单例模式就不是我们今天的重点，感兴趣的小伙伴可以自己下去了解哦。

封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。

####  类的继承 

前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。

在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中**非私有**的成员。

比如说我们一开始创建的狗类，根据种类划分，我们可以将这个大类进一步地细分出来，例如：柯基类，柴犬类。实际上这些划分出来的类，本质上还是狗类，也就是说狗类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。

首先创建一个父类：

```java
public class Dog {
    //狗的名字
    private String name;
    //狗的颜色
    private String colour;
    //狗的年龄
    private int age;

    void eat() {
        System.out.println("狗吃");
    }

    void run() {
        System.out.println("狗跑");
    }

    void sleep(){
        System.out.println("狗睡");
    }
```

接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用extends关键字即可：

```java
public class Corgi extends Dog{
    
}
```

**类的继承可以不断向下，但是同时只能继承一个类，同时，标记为final的类不允许被继承**

当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为`private`，那么子类将无法访问（但是依然是继承了这个属性的）。

同样的，在父类中定义的方法同样会被子类继承。子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法。

是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以[扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。

```java
Corgi corgi = new Corgi();//在Main函数里创建了一个子类对象
corgi.eat();//此处调用了父类的方法
```

此时控制台打印：狗叫

##### 方法的重写 

此时，我们可以用方法的重写来拓展子类的独特能力。例如我们可以在子类里重写父类的方法：

```java
public class Corgi extends Dog{
    public void eat(){
        System.out.println("Corgi eat");
    }
}
```

那么此时控制台打印为：Corgi eat

- 我们如果不希望子类重写某个方法，我们可以在方法前添加final关键字，表示这个方法已经是最终形态

- 如果父类中方法的可见性为private，那么子类同样无法访问，也就不能重写，但是可以定义同名方法

- 我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用`super`关键字：

- 然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性

> 因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限

###### final关键字

final 在 Java 中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦你将引用声明作 final，你将不能改变这个引用了，编译器会检查代码，如果试图将变量再次初始化的话，编译器会报编译错误。

###  抽象

#### 抽象类 

在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象,比如狗类上还有动物类。

在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。

抽象类除了`不能实例化对象`之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。

父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。

在 Java 语言中使用 abstract class 来定义抽象类。

```Java
public abstract class Dog {
    //狗的名字
    private String name;
    //狗的颜色
    private String colour;
    //狗的年龄
    private int age;

    void eat() {
        System.out.println("狗吃");
    }

    void run() {
        System.out.println("狗跑");
    }

    void sleep(){
        System.out.println("狗睡");
    }
```

此时，之前的Main方法中的对于Dog类的实例化语句就会报错。但是Dog类依旧可以被继承。而且具体的实现，需要由子类来完成

####  抽象方法

如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。

Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

**TIPS:抽象方法的访问权限不能为private**

> 因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。

#### 抽象类总结规定

-  抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
- 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
- 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
- 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。
- 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

#### 方法的重载

上面讲了方法的重写，我们接着来看方法的重载。有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？



![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F20%2Fm7BvM1RctLznhrA.png&sign=ca2d1c2cce0f6150d7ab9d9a71f00a0008f1d5883dffb0fc7139fec265dd7cc7)



当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载(Overload)。

一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！这样就可以正常使用了：

`包括我们之前一直在使用的println方法，其实也是重载了很多次的，因为要支持各种值的打印。`

![img](https://www.yuque.com/api/filetransfer/images?url=https%3A%2F%2Fs2.loli.net%2F2022%2F09%2F20%2FN2TRuqEnxrKbpc8.png&sign=472b7a33618662bbe75d75724ead0d70b9215ef2646d67c7c001209879ccc88f)

